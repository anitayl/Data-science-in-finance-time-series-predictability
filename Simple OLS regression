
#%%import packages
import pandas as pd
import yfinance as yf
import pandas as pd
import numpy as np

import statsmodels.api as sm

import os
import pickle
#%%1. Create a dataframe that includes the 10 industry daily returns over the sample period
#clean the data
industry = pd.read_csv("10_Industry_Portfolios_Daily.csv",skiprows=9)
industry.rename(columns = {'Unnamed: 0':'Date'},inplace=True)
industry.dropna(inplace=True)
industry['Date'] = pd.to_datetime(industry['Date'])
industry.iloc[:,1:] = industry.iloc[:,1:].apply(pd.to_numeric)
value_weighted = industry.iloc[:25148,:]
equal_weighted = industry.iloc[25148:,:]

#Jan 1st, 2000 to Dec 31st, 2019 period
industry1 = equal_weighted 
industry1  = industry1.set_index('Date')
lagged_return = industry1.shift(1) 
industry1 = industry1['2000':'2019']
lagged_return = lagged_return['2000':'2019']
#%%2. Create a summary statistics table with mean, sd, and SR (all annualized) returns for each of the industries.
industry_performance = pd.DataFrame()
industryname = list(industry1.columns[:])
for i in industryname:
    industry_performance = industry_performance.append({'Name':i,'Mean':industry1[i].mean()*250, 'SD':industry1[i].std()*(250**.5)},ignore_index=True)
    industry_performance['SR'] = industry_performance['Mean']/industry_performance['SD']

industry_performance.set_index('Name',inplace=True)
print(f"Top performing industry:{industry_performance['SR'].idxmax()} with SR:{industry_performance['SR'].max()}")
print(f"Bottom performing industry:{industry_performance['SR'].idxmin()} with SR:{industry_performance['SR'].min()}")
 #in terms of SR, NoDur is the top performing industry while Telcm is the bottom performing industry
#%% For each of the industries, estimate a regression relating its daily returns to lagged returns of all other industries
#get the regression results and predictions for each industry
OLS_dict = dict()
OLS_pred = pd.DataFrame()
OLS_R = dict()
for industry in industryname:
    print(industry)
    X = lagged_return.loc[:, lagged_return.columns != industry] #To simplify the model, i will only use the one_day-lagged return of all other industries as the features
    Y = industry1[industry] #I use the daily return of the industry as the label
    model = sm.OLS(Y,sm.add_constant(X))
    results = model.fit()
    R = results.rsquared
    OLS_R[industry] = R
    print('Industry: ', industry, '\n', results.summary())
    OLS_dict[industry] = results
    ypred = results.predict(sm.add_constant(X)) #Use the estimated regression coefficients in (3) to form daily return predictions for each of these industries
    OLS_pred = pd.concat([OLS_pred,pd.DataFrame({industry:ypred})],axis=1,join='outer')
    
OLS_R = pd.DataFrame(OLS_R.items(), columns=['Industry', 'R^2'])
print(OLS_R.sort_values(by=['R^2'], ascending=False))
#Although R^2 is really small for all industries, while Telcm seems to have the highest R^2, which equals 0.022064, 
#implying that Telcm appears to be most influenced by the lag of other industries.
# There are many reasons that may explain the low R^2 of the model 
#1.unsufficient features in the model.
#2. OLS is not a good model to fit the data.
#3. The model is overfitting, cross validation is needed to address the problem.
OLS_dict['Telcm'].summary()
#Accoring to the regression result, Telm is positively influenced by the lag of Manuf and positively influenced by the lag of HiTec
#%% Use the daily predictions in (4) to form a portfolio that attempts to trade on these predictions. 
#My strategy is to pick the top 3 industries and build an equal-weighted portfolio
K = 3
Highest_Pred = pd.DataFrame()
for i in range(1,K+1):
    col_name = 'high'+str(i)
    Highest_Pred[col_name] = OLS_pred.T.apply(lambda x: x.nlargest(i).idxmin())

OLS_Strat_Rets = pd.Series(dtype='float64')
loc = industry1.columns.get_loc
for d in Highest_Pred.index:
    Cols = Highest_Pred[d:d]  
    Mean_rets = industry1[d:d].iloc[:, Cols.iloc[0,:].apply(lambda x: loc(x))].mean(axis=1)
    OLS_Strat_Rets = OLS_Strat_Rets.append(Mean_rets)
OLS_Strat_Rets = pd.DataFrame({'StratRets':OLS_Strat_Rets})
#%% market data
marketdata = pd.read_csv("F-F_Research_Data_Factors_daily.CSV",skiprows=3)
marketdata.rename(columns = {'Unnamed: 0':'Date'},inplace=True)
marketdata.dropna(inplace=True)
marketdata['Date'] = pd.to_datetime(marketdata['Date'])
marketdata.iloc[:,1:] = marketdata.iloc[:,1:].apply(pd.to_numeric)
marketdata  = marketdata.set_index('Date')
marketdata = marketdata['2000':'2019']
#%% compare the strategy with market 
OLS_Strat_Rets = pd.merge(OLS_Strat_Rets, marketdata['Mkt-RF'], left_index=True, right_index=True, how='left')   
OLS_Strat_Rets = OLS_Strat_Rets/100       
OLS_Strat_Rets.add(1).cumprod().plot(logy=True)    
print('Market Mean ', OLS_Strat_Rets['Mkt-RF'].mean()*250,' SD ', OLS_Strat_Rets['Mkt-RF'].std()*(250**.5), ' SR ', (OLS_Strat_Rets['Mkt-RF'].mean()*250)/(OLS_Strat_Rets['Mkt-RF'].std()*(250**.5)))    
print('Strat Mean ', OLS_Strat_Rets['StratRets'].mean()*250,' SD ', OLS_Strat_Rets['StratRets'].std()*(250**.5), ' SR ', (OLS_Strat_Rets['StratRets'].mean()*250)/(OLS_Strat_Rets['StratRets'].std()*(250**.5)))    
# The sharpe ratio of this portfolio is 1.59, much higher than that of the market,which is only 0.33
